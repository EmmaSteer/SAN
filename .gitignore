#include <stdio.h>
#include <math.h>
#include <stdlib.h>

double courtemach(double dt, double t, double state[32],int BCL, double ACh_conc, double fRyR);
double pulse( double x, int BCL);

double Euluer_inf(double dt, double gate, double inf, double tau);
double Foward_Euler(double dt, double dy, double y);

/* provided by Henggui 1st Aug 2012 Human SAN central cell. Does not reproduce Fig 8c of Chandler et al */
/* the constants are global */
double const    vcell = 20100.0; /* um3 */
double const    vi = 13668;
double const    vup = 1109.52/*0.0552*vcell*/;
double const    vrel = 96.48/*0.0048*vcell*/;
double const    T = 310; /* 37 Celcius */
double const    Tfac = 3; 
double const    Csp = 1e+6; /* pF/cm2 */
double const    Cm = 100.0; /* pF */
double const    F = 96.4867; /* coul/mmol */
double const    R = 8.3143; /* J K-1 mol-1 */
double const    kb = 5.4; /* mM */
double const    nab = 140; /* mM */
double const    cab = 1.8; /* mM */
double const    nac = 140;
double const    cac = 1.8;
double const    kc = 5.4;
double const    gna = 7.8; /* nS/pF */ 
double const    gto = 0.1962; /* nS/pF */ 
double const   gkur = 0.05874;
double const    gkr = 0.029411765; /* nS/pF */
double const    gks = 0.12941176; /* nS/pF */
double const    gcaL = 0.1375; /* nS/pF */ 
double const    ErL = 65.0; /* mV */
double const    gk1 = 0.09; /* nS/pF */ 
double const    gbna = 0.0006744375; /* nS/pF */ 
double const    gbk = 0.0;
double const    gbca = 0.001131; /* nS/pF */ 
double const    inakbar = 0.59933874; /* pA/pF */
double const    kmnai = 10.0; /* mM */
double const    kmko = 1.5; /* mM */
double const    icapbar = 0.275; /* pA/pF */
double const    kmcap = 0.0005; /* mM */
double const    knacalr = 1600.0; /* pA/pF */
double const    kmnalr = 87.5; /* mM */
double const    kmcalr = 1.38; /* mM */
double const    ksatlr = 0.1;
double const    gammalr = 0.35;
double const    trpnbar = 0.070; /* mM */
double const    cmdnbar = 0.050; /* mM */
double const    csqnbar = 10; /* mM */
double const    kmcsqn = 0.8; /* mM */
double const    kmcmdn = 0.00238; /* mM */
double const    kmtrpn = 0.0005; /* mM */
double const    grelbar = 30.0; /* ms-1 */ 
double const    kmup = 0.00092; /* mM */ 
double const    iupbar = 0.005; /* mM/ms */
double const    caupmax = 15.0; /* mM */
double const    kupleak = 0.00033333336/*iupbar/caupmax*/; /* ms-1 */
double const    tautr = 180.0; /* ms */
double const 	gf = 0.025; //ns/pf
float const    gcaT = (0.15*0.22)/17.62;;//(0.45*0.22)/17.62; /* nS/pF */ 
float const    EcaT = 45.0; /* mV */


double const gKAcH_max = 13*2.3362448698;//13*2.3362448698; // nS/pF

double const Vss = 2*4.99232e-5;
double const rjunct = 6.5;
double const lcell = 122.051;

//Ca diffusion
double const dx = 1.625;
//double r start, rend, j, j'  -> figure out
// add in after electrophysiology is done
double Aj_nj = 2492.324412;// = M_PI*rjunct*2*lcell*0.5; // atea between junct and non junct
double xj_nj = 0.822500;// = 0.02/2 + dx/2; // diffusion distance from center to center of junct to first njunct 
double xj_nj_Nai = 3.260000;// = 0.02/2 + 2*dx; // diffusion distance from center of junct to center of njunct (between 2nd and 3rd njunct)

double Vnonjunct3 = 6*0.002531;
double VSR3 = 2*0.000057;
double VSR4 = 2*0.000080;
double Vcytosol = 0.008150;
double Vnonjunct_Nai = 0.008100;

double BCa = 24e-3; 
double SLlow = 165; 
double SLhigh = 13; 

double KdBCa = 2.38e-3;
double KdSLlow = 1.1;
double KdSLhigh = 13e-3;

double CSQN =  6.7;
double KdCSQN = 0.8;

double BNa = 1.1319;
double KdBNa = 10;

double DCa = 780;// % µm2/s
double DCaSR = 44;//
double DCaBm = 25; //% µm2/s

double DNa = 0.12;

double SERCAKmf = 0.25e-3;
double SERCAKmr = 1.8;
double k4 = 7.5 ;// % pump rate
double k3 = 2.314815; //= k4 / SERCAKmr^2;
double k1 = 7500000.000000;// = 1000^2 * k4;
double k2 = 0.468750;// = k1 * SERCAKmf^2;
double cpumps = 40e-3;
double kSRleak = 6e-3;

double GNa, Gto, GKur, GCaL, GKs, GKr, GK1, GCap, GNACA, GCAT;
double GCAB, GNAB, GKB;
double BULK_CONST;
double CaL_inac_shift;
double CaL_ac_shift;
double IKr_ac_grad;
double IKs_ac_grad;
double IK1_V_shift;
double Gf;
double If_vshift;
double IKur_ac_shift, IKur_inac_shift, IKur_ac_grad, IKur_inac_grad;
double IKr_ac_shift, IKr_grad, IKs_shift, IKs_grad;
double tau_INa_act, tau_INa_inact;

double Ito_vshift,  ICaL_tau_rate, GSR_leak; 
double If_grad;


double ICAL, ITO, IKUR, ICAP, INACA, INA, IKS;
double O_JSERCASR, O_JSERCASRss, O_JBULKSERCA, O_JBULKSERCAss, O_JRELss, O_JREL, O_JSRLEAK, O_JSRLEAKss;
double IREL, RYR;
double IF, ICAT;

double Integral_itot;
double Integral_ITO, Integral_IKUR;

int main( int argc, char *argv[]){

double dt= 0.005; /* time step in milliseconds */
double state[32];
double v;
double t = 0;
double Total_time = 30000;
int it = 0, i;
int max_it = Total_time/dt;
//int BCL = 1000;
FILE * out, *out2;
int cell_type; // 0 - default cell 1 - PM, 2 - CT, 3 - APG, 4 - AVR, 5 - BB
//double vmax = -80.0, vmin = 100, t1, t2, v90;
//int checklow=0, checkhi=0;

//ISO
double ISO;
double fICaL;
double fIKs;
double fIKur;
double fRyR;
double fINa;
double fPLB;
double fIf;


Integral_itot = Integral_ITO = Integral_IKUR = 0;

//ACh
double ACh_conc;
int S2;

//cell_type = atoi(argv[2]);
ACh_conc = 1E-6 * atof(argv[1]);
ISO = atof(argv[2]);


fICaL = 1/ ( 1 + exp((-4.362*(log(ISO) + 3.27)) ) );
fRyR = 1/ ( 1 + exp((-2.55*(log(ISO) + 1.2)) ) );
fIKs = 1/ ( 1 + exp((-4*(log(ISO) + 1.4)) ) );
fIKur = 1/ ( 1 + exp((-1.8*(log(ISO) + 2.2)) ) );
fINa = 1/ ( 1 + exp((-2.55*(log(ISO) + 2.5)) ) );
fPLB = 1/ ( 1 + exp((-3*(log(ISO) + 2.2)) ) );

fIf = fINa;

//fICaL = fRyR = fIKs = fINa = fPLB = fIKur;

// default sclaing factors
GNa = Gto = GKur = GCaL = GKs = GKr = GK1 = GCap = Gf = GNACA = GCAT = GSR_leak = 1.0;
GCAB = GKB = GNAB = 1;
Gf = 0.4;//0.25;
BULK_CONST = 1.2;
CaL_inac_shift = 0;
CaL_ac_shift = 0;
IREL = RYR = 1;
IK1_V_shift = 0;
If_vshift = 0;
IKur_ac_shift = IKur_inac_shift = 0;
IKr_ac_shift = IKs_shift = 0;
IKur_ac_grad = IKur_inac_grad = 1;
IKr_grad = IKs_grad = 1;
tau_INa_act = tau_INa_inact = 1;
Ito_vshift = 0;
ICaL_tau_rate = 1;
If_grad = 1;



	GNa = 0.06;
	GKur = 0.26;
	GK1 = 0.42;
	GCAT =4.5*17;//5.2*17;
	Gf = 4.4;
	GNACA = 0.5; 
	Gto = 0.4;
	GCaL = 0.68;
	GKs = 0.69;
	GKr = 0.45;
	BULK_CONST = 3;	
	If_grad = 1.1;


//ISO scales current values of all
	     GCaL = (1 + (fICaL*2)) * GCaL;
   		 GKur = (1+ (fIKur*0.6)) * GKur;
//	    GKs = (1 + (fIKs*2)) * GKs;
	  	 GKs = (1 + (fIKs*1.5)) * GKs;  
		 BULK_CONST = (BULK_CONST + (fPLB*0.1));
    	 GNa = (1 - (fINa*0.5)) *GNa;
    	 CaL_inac_shift = CaL_inac_shift  + (fICaL*5);
 	  	 CaL_ac_shift = CaL_ac_shift + (fICaL*5) ;
		 If_vshift = If_vshift + (fIf * -7); 

	// Ach If
	
	If_vshift = If_vshift + (-7.2 * ( (pow(ACh_conc,0.69))/( pow(1.26E-8 ,0.69 ) + (pow(ACh_conc,0.69)  ) ) ));

// AF remodelling also scales current values
int remodelling;
//remodelling = atoi(argv[5]);
//S2 = atoi(argv[6]);


	int BCL;
    double BCLint, stimint;
    int intBCL, intstim, stimcount, timeint, durationint;
    double Istim, stimamp, stimduration;
    int stimflag;
    int outcount, outfreq;

	BCL = 700000;//atoi(argv[1]);//400;
    outfreq = 100;
    stimduration = 2.0;

    // Stimulation stuff calculation
    stimint = 1/dt;
    intstim = stimint;
    intBCL = BCL*intstim;
    durationint = stimduration*stimint;
    stimcount = stimflag = timeint = 0;

    // APD stuff
    int APD_switch = 0;
    double v90;
    double vmax, vmin;
    int APD_count = 0;
    float timeAPDstart;
    int counter;
    int vmax_switch = 0;
    FILE *APD_out;



/* steady-state initial conditions as used in the manuscript */

//if (cell_type == 0){

state[0] = -56.256408;
state[1] = 0.128290;
state[2] = 0.083055;
state[3] = 0.069699;
state[4] = 0.003072;
state[5] = 0.580950;
state[6] = 0.266189;
state[7] = 0.120324;
state[8] = 11.170000;
state[9] = 134.698941;
state[10] = 0.000238;
state[11] = 0.000202;
state[12] = 1.207137;
state[13] = 1.207031;
state[14] = 0.012762;
state[15] = 0.013767;
state[16] = 0.000033;
state[17] = 0.999712;
state[18] = 0.328677;
state[19] = 0.000489;
state[20] = 0.723881;
state[21] = 0.213205;
state[22] = 0.005456;
state[23] = 0.768002;
state[24] = 0.002901;
state[25] = 0.843262;
state[26] = 0.594193;
state[27] = 0.380302;
state[28] = 0.480759;
state[29] = 0.031234;
state[30] = 0.055628;
state[31] = 0.162714;


double Vm;
double Iion_tot;
double dvdt, dvdt_max;

double pace1, pace2;
int pace_which = 0;


        out = fopen ("SAN.txt", "wt");
        APD_out = fopen("SAN_APD.txt", "wt");




v = state[0];
Vm = v;

double APD_out_end[2];
int apd_out_which = 0;

int voltage_clamp = 0;

if (voltage_clamp == 0){

for (it = 0; it < max_it; it++){
	
	Iion_tot =  (courtemach(dt, t, state, BCL, ACh_conc, fRyR))/Cm;

	if (S2 == 0){	
	if(timeint == 0 || timeint%intBCL == 0) stimflag = 1;
            if(stimflag == 1){
                Istim = -20.00;
                stimcount ++;
                if (stimcount >= durationint){
                    stimflag = 0;
                    stimcount = 0;
                } // end if
            } // end if
            else Istim = 0;
	}
	else {
	           if (t < (20*BCL) - (BCL-2)){
    if(timeint == 0 || timeint%intBCL == 0) stimflag = 1;
            if(stimflag == 1){
                Istim = -20.00;
                stimcount ++;
                if (stimcount >= durationint){
                    stimflag = 0;
                    stimcount = 0;
                } // end if
            } // end if
            else Istim = 0;
    }
    else {
     //   if (t < ((20*BCL) + s2) || t > ((20*BCL) + s2 + 2)) Istim = 0;
       // else Istim = -20.00;
        if (t > (19*BCL + S2) && t < 19*BCL + S2 + 2) Istim = -20.0;
        else Istim = 0.0;

    }


	}


        // APD
        if (Istim != 0 && APD_switch == 0){
            APD_switch = 1;
            vmax = -60;
            timeAPDstart = t;
            vmin = Vm;
            counter = 0;
        }
        if (APD_switch == 1){
            if (Vm > -30.0){
                if (Vm > vmax){
                    vmax = Vm;
                }
                else vmax_switch = 1;
                if (vmax_switch == 1) APD_switch = 2;
            }
        }
        if (APD_switch == 2){
            v90 = 0.9*(vmax-vmin);
            if (Vm < (vmax - v90)){
                APD_switch = 0;
                APD_count ++;
                vmax_switch = 0;
                fprintf (APD_out, "%d %f\n", APD_count * BCL, t-timeAPDstart);
		if (apd_out_which == 0) {
			APD_out_end[0] = t-timeAPDstart;
			apd_out_which = 1;
		}
		else if (apd_out_which == 1){
			APD_out_end[1] = t-timeAPDstart;
			apd_out_which = 0;
		}
            }
        }

	v = v - dt*(Iion_tot + Istim);
	Integral_itot = Integral_itot + dt*(Iion_tot + Istim);

	if ( t > 7000 && t < 7700){
		Integral_ITO = Integral_ITO + dt*ITO;
		Integral_IKUR = Integral_IKUR + dt*IKUR;
	}


	state[0] = v;

	if (it > max_it/2){
	dvdt = (v - Vm)/dt;
    if (dvdt > dvdt_max) dvdt_max = dvdt;
	}

	 if (v > 0 && Vm <= 0){
        if (pace_which == 0){
             pace1 = t;
             pace_which = 1;
            }
        else {
            pace2 = t;
            pace_which = 0;
        }
    //  printf("%f\n", pace);
    }


	Vm = v;

	 timeint = t*intstim;
        outcount++;


	if(outcount%outfreq == 0) fprintf(out," %f   %f  %f  %f   %f  %f %f %f %f %f %f %f %f %f %f %f %f %f\n",  t, state[0], (state[10]+((state[11])))/2, IF/Cm, ICAT/Cm, IKUR/Cm, ICAP/Cm, INACA/Cm, O_JSERCASR, O_JSERCASRss, O_JBULKSERCA, O_JBULKSERCAss, O_JRELss, O_JREL, O_JSRLEAK, O_JSRLEAKss, state[12], state[13]);

/*	int state_count;
	if (t > 28466 && t <= 28467){
		for(state_count = 0; state_count < 32; state_count ++){
			printf("state[%d] = %f;\n", state_count, state[state_count]);
		}
	}
*/
	t  = t + dt;

	

}// end time loop

} // end voltage clamp loop

else if (voltage_clamp == 1){

printf("voltage clamping\n");

float peak_Ito = 0.0;
float IKUR_out;
double Vhold, Vstart, Vend;
double clamp_time;
FILE *volt_out, *volt_out2, *current_out;
double x;
int kur_switch;
float PEAK_PEAK;

Vstart = -40.0;
Vend = 50.0;
Vhold = -80.0;
clamp_time = 350.0; // Ito/IKur
//clamp_time = 100.0; // ICaL

//lt_out = fopen("ito_clamp.txt", "wt");	
volt_out = fopen("INA_clamp.txt", "wt");
volt_out2 = fopen("IKur_clamp.txt", "wt");
current_out = fopen("Ito_clamp_trace.txt", "wt");	

	for (v = Vstart; v < Vend+1; v = v + 10){

//	v = 40;
	
	peak_Ito = 0.0;
	kur_switch = 0;

		for (t = 0.0; t < 3*clamp_time; t = t+dt){
		
			if (t < clamp_time) state[0] = Vhold;
			else if (t < 2*clamp_time) state[0] = v;
			else state[0] = Vhold;		

			x = (courtemach(dt, t, state, BCL, 0, 0))/Cm;			

			if (t > clamp_time && t < 2*clamp_time){
			//	if (ITO > peak_Ito) peak_Ito = ITO;
			if (IKS > peak_Ito) peak_Ito = IKS;
			}
			if ( t >= (2*clamp_time-dt) && kur_switch == 0){
				IKUR_out = IKUR;
				kur_switch = 1;
			}
			if (peak_Ito < PEAK_PEAK) PEAK_PEAK = peak_Ito;

		fprintf(current_out, "%f %f\n", t, ITO/Cm);
		}

		fprintf(volt_out, "%f %f\n", v, peak_Ito/Cm);
		fprintf(volt_out2, "%f %f\n", v, IKUR_out/Cm);
		

	}

printf("%f\n", PEAK_PEAK);

fclose(volt_out);
fclose(volt_out2);
fclose(current_out);

} // end voltage clamp if loop

fclose (out);


//printf ("BCL = %d Cell = %d Difference = %f\n", BCL, cell_type, APD_out_end[0] - APD_out_end[1]);


//printf("Ito = %f Ikur = %f\n", Integral_ITO, Integral_IKUR);

} // end main

double Euler_inf(double dt, double gate, double inf, double tau){

        gate = inf + (gate - inf) * exp(-(dt)/tau);

        return gate;

}

double Foward_Euler(double dt, double dy, double y){

        double Y;
        Y = y + (dt)*dy;
        return Y;

}
double courtemach(double dt, double t, double state[30], int BCL, double ach_conc, double fRyR)
{

	double     V = state[0];
	double     m = state[1];
	double     h = state[2];;
	double     j = state[3];
	double     d = state[4];
	double     f = state[5];
	double     xr = state[6];
	double     xs = state[7];
	double     nai = state[8];
	double     ki = state[9];
	double     Cass = state[10];
        double     Cai =  state[11];
        double 	   CaSR1 = state[12];
        double     CaSR2 = state[13];
        double	    SERCACa = state[14];
	double      SERCACass = state[15];
    	double 	  RyRoss = state[16];
	double    RyRcss = state[17];
	double        RyRass = state[18];
    	double 	RyRo3 = state[19];
    	double RyRc3 = state[20];
    	double RyRa3 = state[21];
	double 	Itr = state[22];
	double 	Its = state[23];
	double  Isusr = state[24];
	double  Isuss = state[25];
	double     fca = state[26];

	double AcHj = state[27];
	double AcHk = state[28];

	double if_y = state[29];

	double dd = state[30];
	double ff = state[31];



	/* computed quantities */

	double Ek, Ena, Eca,ina,ik,ibna,ibk,ibca,inak,ik1;
	double ito,ikur,ikr,iks;
	double iab,inaca,icaL;
	double naidot,kidot;
	double caidot,irel;
	double itr,iup,iupleak;
	double fnak,caflux,icap,sigma;
	/* utility variables */
	double a,b,tau,inf,vshift;

	double ICaL,gCaL, ECa_app;
        double kCan, kCa;
        double fcainf;
	double icaT;

	double gKAcH, IKAcH, aj, bj, ak, bk, khalf_ach, nkach;
	




	/* compute Ek */
	Ek = 26.71*log(kc/ki);
	/* compute Ena */
	Ena = 26.71*log(nac/nai);
	/* compute Eca */
	Eca = 13.35*log(cac/Cass);
	/* compute sodium current */
	ina = GNa*Cm*gna*m*m*m*h*j*(V-Ena);
	INA = ina;

	/* maleckar currents */
	// Ito
//	double gt;
//	gt =  (1.09*7.5)/*/50*/;

	// If
	double If, if_fna, if_fk;
	if_fna = 0.2677;
	if_fk = 1- if_fna;
	
//	If = Cm*gf*if_y*(if_fna*(V-Ena) + if_fk* (V-Ek) );
	If = Gf*Cm*gf*if_y*(V-(-22));
	IF = If;
	
	inf = 1/ (1 + exp((V+90.95+If_vshift)/(10.1*If_grad))   );
	tau = 1/ (1.2783E-04 * exp(-V/9.2424) + 121.6092 * exp(V/9.2424)   );

	if_y = inf + (if_y - inf)*exp(-dt/tau);


	// ICaT
	icaT = GCAT*Cm*gcaT*ff*dd*(V-EcaT);
	ICAT = icaT;

	a = 1.0680*exp((V+26.3)/30.0);
    b  = 1.0680*exp(-(V+26.3)/30.0);
    tau = 1.0/(a+b);
    inf = 1.0/(1.0+exp(-(V+37.0)/6.8));
    dd = inf + (dd-inf)*exp(-dt/tau);

    a = 0.0153*exp(-(V+71.0)/83.3);
    b  = 0.0150*exp((V+71.0)/15.38);
    tau = 1.0/(a+b);
    inf = 1.0/(1.0+exp((V+71.0)/9.0));
    ff = inf + (ff-inf)*exp(-dt/tau);




   ito = ((Cm * Gto * gto * (Itr) * (Its) * ((V) - Ek)));
	ITO = ito;

    // r gate
    inf = 1/(1+exp(((V)-1+Ito_vshift)/-11));
    tau = 0.0035*exp( -pow((((V)+0)/30),2) ) + 0.0015;
//    Itr = Euler_inf(dt/1000, Itr, inf, tau);
	Itr = inf + (Itr - inf) * exp(-(dt/1000)/tau); // dt/1000 to convert from s to ms

    // s gate
    inf = 1/(1+exp(((V)+40.5)/11.5));
    tau = 0.025635*exp( -pow((((V)+52.45)/15.8827),2) ) + 0.01414;
   // Its = Euler_inf(dt/1000, Its, inf, tau);
	Its = inf + (Its - inf) * exp(-(dt/1000)/tau);
		
	// Ikur
//	double gsus;
//	gsus = 0.89*2.75;

	ikur =Cm* GKur * gkur * (Isusr) * (Isuss) * ((V) - Ek);
	IKUR = ikur;

    // r gate
    inf = 1/(1 + exp(((V) + 6 + IKur_ac_shift)/(-8.6*IKur_ac_grad)));
  //   inf = 1/(1+exp(((V)-8)/-11*0.6));

	  tau = 0.009/(1 + exp(((V) + 5)/12)) + 0.0005;
  //  susr = Euler_inf(dt/1000, susr, inf, tau);
	Isusr = inf + (Isusr - inf) * exp(-(dt/1000)/tau);

    // s gate
    inf = 1/(1 + exp(((V) + 7.5 + IKur_inac_shift)/(10*IKur_inac_grad)));
// inf = 1/(1+exp(((V)+32.5)/11.5*0.65));	
    tau = 0.59/(1 + exp(((V) + 60)/10)) + 3.05;
//    suss = Euler_inf(dt/1000, suss, inf, tau);
	Isuss = inf + (Isuss - inf) * exp(-(dt/1000)/tau);

	// IKACh
	khalf_ach = 2.8E-07;
	nkach = 1.5;

	gKAcH = gKAcH_max * AcHj * AcHk * ( pow(ach_conc, nkach) / ( pow(khalf_ach, nkach) + pow(ach_conc, nkach) ) );
    IKAcH = gKAcH * (kc/(10+kc)) * ((V - Ek - 5) / (1 + exp( ( ( V - Ek - 145)*F)/(2.5*R*T))));

    aj = 63.99740379;
    bj = 132.4254996 / (1 + exp (-(V + 36.58863658)/8.18192955));

    tau = 1/(aj+bj);
    inf = aj*tau;
    AcHj =  inf + (AcHj-inf)*exp(-dt/ tau);

    ak = 3.00882853;
    bk = 7.272612229/ (1 + exp (-(V + 69.84216904 )/ (0.369147) ) );

    tau = 1/(ak+bk);
    inf = ak*tau;
    AcHk =  inf + (AcHk-inf)*exp(-dt/ tau);
	


	/* compute the rapid delayed outward rectifier K current */
	ikr = GKr *Cm*gkr*xr*(V-Ek)/(1+exp((V+15)/22.4)); 
  
	/* compute the slow delayed outward rectifier K current */
	iks = GKs *Cm*gks*xs*xs*(V-Ek);

 IKS = iks;

	ik = ikr + iks;
  
  	/* compute calcium current */
  	icaL =/* 2.37*/2*GCaL*Cm*gcaL*d*f*fca*(V-ErL);

	ICAL = icaL;

  	/* update the fca gate immediately */
 	inf = 1/(1+((Cass)/0.00035)); 
 	tau = 2.0; 
 	fca = inf + (fca-inf)*exp(-dt/tau); 

 	/* compute time independent potassium current */
 	ik1 = GK1*Cm*gk1*(V-Ek+IK1_V_shift)/(1+exp(0.07*(V+80+IK1_V_shift))); 
//iab - NO3- sensitive background current
	iab=0;
	iab = Cm*0.0003879*(V+69.6)/(1-0.8377*exp((V+49.06)/1056));
 	/* compute ibna background current */
 	ibna = GNAB*Cm*gbna*(V-Ena);
  
 	/* compute potassium background current */
 	ibk = GKB*Cm*gbk*(V-Ek);
	  
 	/* compute ibca background current */
 	ibca = GCAB*Cm*gbca*(V-Eca);
	  
 	/* compute inak sodium-potassium pump current, LR-style */
 	sigma = (exp(nac/67.3)-1)/7.0;
 	fnak = 1/(1+0.1245*exp(-0.1*V*F/(R*T))+0.0365*sigma*exp(-V*F/(R*T)));
 	inak = Cm*inakbar*fnak*kc/(kc+kmko)/(1+pow(kmnai/nai,1.5));
	  
 	/* compute icap calcium pump current LR-style */
 	icap = 1.4*GCap*Cm*icapbar*Cass/(/*1.013e-04*/Cass+kmcap); 
	ICAP = icap;
  
 	/* compute inaca exchanger current LR-style */
 	inaca = GNACA*Cm*knacalr/(pow(kmnalr,3.0)+pow(nac,3.0))/(kmcalr+cac)/
 	  (1+ksatlr*exp((gammalr-1)*V*F/(R*T)))*
 	   (nai*nai*nai*cac*exp(V*gammalr*F/(R*T))-nac*nac*nac*(Cass)*
 	    exp(V*(gammalr-1)*F/(R*T)));  
	INACA = inaca;
  
 	/* compute naidot sodium concentration derivative */
 	naidot = (-3*inak-3*inaca-ibna-ina)/(F*vi);
  
 	/* compute kidot potassium concentration derivative */
 	kidot = (2*inak-ik1-ito-ikur-ikr-iks-ibk)/(F*vi);
  
   	/* update all concentrations */
   	nai = nai + dt*naidot;
   	ki = ki + dt*kidot;
  
   	/* update ina m gate */
   	a = 0.32*(V+47.13)/(1-exp(-0.1*(V+47.13)));
   	if (fabs(V+47.13) < 1e-10) a = 3.2; /* denominator = 0 */
   	b = 0.08*exp(-V/11);
   	tau = tau_INa_act*(1/(a+b)); inf = a*tau;
   	m = inf + (m-inf)*exp(-dt/tau);
  
   	/* update ina h gate */
   	if (V >= -40.0)
    {
      a  = 0.0;
      b = 1/(0.13*(1+exp((V+10.66)/-11.1)));
    }
   	else
    {
      a = 0.135*exp((V+80)/-6.8);
      b = 3.56*exp(0.079*V)+3.1e5*exp(0.35*V);
    }
   	tau = tau_INa_inact*(1/(a+b)); inf = a*tau;
   	h = inf + (h-inf)*exp(-dt/tau);
  
   	/* update ina j gate */
   	if (V >= -40.0)
    {
      a  = 0.0;
      b = 0.3*exp(-2.535e-7*V)/(1+exp(-0.1*(V+32)));
    }
   	else
    {
      a = (-1.2714e5*exp(0.2444*V)-3.474e-5*exp(-0.04391*V))*(V+37.78)/
	(1+exp(0.311*(V+79.23)));
      b = 0.1212*exp(-0.01052*V)/(1+exp(-0.1378*(V+40.14)));
    }
   	tau = 1/(a+b); inf = a*tau;
   	j = inf + (j-inf)*exp(-dt/tau);
  
   	/* update oa ito gate */
   	/* corrected for 37 deg */
   	/* define an voltage shift due to junctional potential
    	  and effect of Cd++ */
   	/* update the xr ikr gate */
   	vshift = 0;
   	a = 0.0003*(V-vshift+14.1)/(1-exp((V-vshift+14.1)/-5));
   	b = 0.000073898*(V-vshift-3.3328)/(exp((V-vshift-3.3328)/5.1237)-1);
   	if (fabs(V-vshift+14.1) < 1e-10) a = 0.0015; /* denominator = 0 */ 
   	if (fabs(V-vshift-3.3328) < 1e-10) b = 3.7836118e-4; /* denominator = 0 */ 
   	tau = 1/(a+b); 
   	inf = 1/(1+exp((V+IKr_ac_shift+14.1)/(-6.5*IKr_grad)));
   	xr = inf + (xr-inf)*exp(-dt/tau);
  
   	/* update the xs ikr gate */
   	vshift = 0;
   	a = 0.00004*(V-vshift-19.9)/(1-exp((V-vshift-19.9)/-17));
   	b = 0.000035*(V-vshift-19.9)/(exp((V-vshift-19.9)/9)-1);
   	if (fabs(V-vshift-19.9) < 1e-10) /* denominator = 0 */
    {
      a = 0.00068; 
      b = 0.000315; 
    }
   	/* tau reduced by 50% as described in manuscript */
   	tau = 0.5/(a+b); 
   	inf = sqrt(1/(1+exp((V-IKs_shift-19.9)/(-12.7*IKs_grad))));
   	xs = inf + (xs-inf)*exp(-dt/tau);

   	/* update icaL d gate */
   	vshift = CaL_ac_shift; 
   	a = 1/(1+exp((V-vshift+10)/-6.24));
   	tau = a*(1-exp((V-vshift+10)/-6.24))/(0.035*(V-vshift+10));
   	if (fabs(V-vshift+10) < 1e-10) tau = a*4.579; /* denominator = 0 */
   	inf = 1/(1+exp((V-vshift+10)/-8));
   	d = inf + (d-inf)*exp(-dt/tau);
	  
   	/* update icaL f gate */
   	vshift = CaL_inac_shift;
   	inf = exp(-(V-vshift+28)/6.9)/(1+exp(-(V-vshift+28)/6.9));
   	tau = ICaL_tau_rate*(1.5*2*3/(0.0197*exp(-0.0337*0.0337*(V-vshift+10)*
			    (V-vshift+10))+0.02));
   	f = inf + (f-inf)*exp(-dt/tau); 

		//new concs

        double betass;
    betass = pow(( 1 + SLlow*KdSLlow/pow(((Cass) + KdSLlow),2) + SLhigh*KdSLhigh/pow(((Cass) + KdSLhigh),2) + BCa*KdBCa/pow(((Cass) + KdBCa),2)  ),(-1));

        double betai, gammai;
        betai = pow(( 1 + BCa*KdBCa/pow((Cai + KdBCa),2)  ),(-1));
        gammai = BCa*KdBCa/pow((Cai + KdBCa),2);

        double betaSR1, betaSR2;
        betaSR1 = pow( ( 1 + CSQN*KdCSQN/pow((CaSR1 + KdCSQN),2) ),(-1));
        betaSR2 = pow( ( 1 + CSQN*KdCSQN/pow((CaSR2 + KdCSQN),2) ),(-1));

        double Jj_nj;
    Jj_nj = DCa * Aj_nj / xj_nj * ((Cass)-Cai)*1e-6;

        double J_SERCASR, J_bulkSERCA;
        double J_SERCASRss, J_bulkSERCAss;

        J_SERCASR =  (-k3*pow(CaSR1,2)*(cpumps-SERCACa)+k4*(SERCACa))*Vnonjunct3*2;
    J_bulkSERCA = (k1*pow(Cai,2)*(cpumps-(SERCACa))-k2*(SERCACa))*Vnonjunct3*2;

        J_SERCASRss = (-k3*pow(CaSR2,2)*(cpumps-(SERCACass))+k4*(SERCACass))*Vss*2;
    J_bulkSERCAss = (k1*pow((Cass),2)*(cpumps-(SERCACass))-k2*(SERCACass))*Vss*2;

    double RyRtauadapt = 1;

    double RyRtauactss = 5e-3;
    double RyRtauinactss = 15e-3;
        double  RyRtauact = 18.75e-3;
    double RyRtauinact = 87.5e-3;


	double nuss = 625*Vss;
    double RyRSRCass = (1 - 1/(1 +  exp((CaSR2-0.3)/0.1)));
    double RyRainfss = 0.505-0.427/(1 + exp((( Cass+ (fRyR*Cass) )*1000-0.29)/0.082));
    double RyRoinfss = (1 - 1/(1 +  exp(((Cass + (fRyR*Cass)   )*1000-((RyRass) + 0.22))/0.03)));
    double RyRcinfss = (1/(1 + exp(((Cass + (fRyR*Cass ))*1000-((RyRass)+0.02))/0.01)));
    double Jrelss = nuss * ( (RyRoss) ) * (RyRcss) * RyRSRCass * ( CaSR2 -  (Cass) );

        double nu3 = 1*Vnonjunct3;
    double RyRSRCa3 = (1 - 1/(1 +  exp((CaSR1-0.3)/0.1)));
    double RyRainf3 =  0.505-0.427/(1 + exp(( (Cai + ( fRyR*Cai)  ) *1000-0.29)/0.082));
    double RyRoinf3 = (1 - 1/(1 +  exp(( (Cai + ( fRyR*Cai) )*1000-((RyRa3) + 0.22))/0.03)));
    double RyRcinf3 = (1/(1 +  exp(( (Cai + (fRyR*Cai ) ) *1000-((RyRa3)+0.02))/0.01)));
    double Jrel3 = nu3 * ( (RyRo3) ) * (RyRc3) * RyRSRCa3 * ( CaSR1 -  Cai );


		Jrelss = IREL* Jrelss;
		Jrel3 = IREL*Jrel3;
//	Jrelss = 0;

    double JSRCaleak3 = GSR_leak*kSRleak * ( CaSR1 - Cai ) * Vnonjunct3;
    double JSRCaleakss = GSR_leak*kSRleak * ( CaSR2 - (Cass) ) * Vss;

	O_JSERCASR = J_SERCASR;
	O_JSERCASRss = J_SERCASRss;
	O_JBULKSERCA = J_bulkSERCA;
	O_JBULKSERCAss = J_bulkSERCAss;
	O_JRELss = Jrelss;
	O_JREL = Jrel3;
	O_JSRLEAK = JSRCaleak3;
	O_JSRLEAKss = JSRCaleakss;

        double JCa, JCass;
        JCa = -BULK_CONST*J_bulkSERCA + JSRCaleak3 + Jrel3 + Jj_nj;
        JCass = -Jj_nj + JSRCaleakss - BULK_CONST*J_bulkSERCAss + Jrelss;

        double JSRCa1, JSRCa2;
        JSRCa1 = J_SERCASR - JSRCaleak3 - Jrel3;
    JSRCa2 = J_SERCASRss - JSRCaleakss - Jrelss;

double dy;

        dy = 0.5*(-J_SERCASR + J_bulkSERCA)/Vnonjunct3;
    SERCACa = Foward_Euler(dt/1000, dy, SERCACa);
    dy = 0.5*(-J_SERCASRss + J_bulkSERCAss)/Vss;
    SERCACass = Foward_Euler(dt/1000, dy, SERCACass);

        RyRoss = Euler_inf(dt/1000, RyRoss, RyRoinfss, RyRtauactss);
    RyRcss = Euler_inf(dt/1000, RyRcss, RyRcinfss, RyRtauinactss);
    RyRass = Euler_inf(dt/1000, RyRass, RyRainfss, RyRtauadapt);
        RyRo3 = Euler_inf(dt/1000, RyRo3, RyRoinf3, RyRtauact);
    RyRc3 = Euler_inf(dt/1000, RyRc3, RyRcinf3, RyRtauinact);
    RyRa3 = Euler_inf(dt/1000, RyRa3, RyRainf3, RyRtauadapt);

        dy =  betass * ( JCass/Vss + ((-( RYR*icaL) - ibca - icap - icaT + 2*inaca)) / (2*Vss*1000*F) );
    Cass = Foward_Euler(dt/1000, dy, Cass);

        dy = /*betai * (DCa + gammai*DCaBm) * ( (Cai[4]-2*Cai[3]+Cai[2])/(dx*dx) + (Cai[4]-Cai[2])/(2*3)*(dx*dx) ) - 2*betai[3]*gammai[3]*DCaBm/(KdBCa + Cai[3]) * pow(((Cai[4]-Cai[2])/(2*dx)),2) + */JCa/Vnonjunct3*betai;
   Cai = Foward_Euler(dt/1000, dy, Cai);

        dy =  betaSR1* (DCaSR) * ( (CaSR2-2*CaSR1+CaSR1)/(dx*dx) + (CaSR1-CaSR2)/(2*3*(dx*dx)) ) + JSRCa1/VSR3*betaSR1;

    CaSR1 = Foward_Euler(dt, dy, CaSR1);

    dy = betaSR2 * (DCaSR) * ( (CaSR2-2*CaSR2+CaSR1)/(dx*dx) + (CaSR2-CaSR1)/(2*4*(dx*dx)) ) + JSRCa2/VSR4*betaSR2;
   
 CaSR2 = Foward_Euler(dt, dy, CaSR2);


  
   	/* update membrane voltage */
	double Itot;
	Itot = ina+icaL+icap+ik1+ito+ikur+ikr+iks+ibna+ibk+ibca+inak+inaca+iab+IKAcH+If+icaT;

//	state[ 0] = V ;
	state[ 1] = m ;
	state[ 2] = h ;
	state[ 3] = j ;
	state[ 4] = d ;
	state[ 5] = f ;
	state[ 6] = xr ;
	state[ 7] = xs ;
	state[9] = ki ;
    state[10] = Cass;
    state[11] = Cai;
    state[12] = CaSR1;
    state[13] = CaSR2;

    state[14] = SERCACa;
    state[15] = SERCACass;

    state[16] = RyRoss;
    state[17] = RyRcss;
    state[18] = RyRass;
    state[19] = RyRo3;
    state[20] = RyRc3;
    state[21] = RyRa3;
	state[22] = Itr;
	state[23] = Its;
	state[24] = Isusr;
	state[25] = Isuss;
	state[26] = fca ;

	state[27] =   AcHj;
    state[28] =  AcHk;


	state[29] = if_y;
	state[30] = dd;
	state[31] = ff;

	return Itot;

}

double pulse( double x, int BCL)
{

	//double BCL = 500;
	double y ;
	if ( x <= BCL )
	{
		y = 0.0;
	}
	else
	{
		if ( x >= BCL+2 )
			y = 0 ;
		else 
			y = -2.0e3;
	}

	return y ;

}



